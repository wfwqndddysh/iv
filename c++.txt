===============================================================================
头文件

cstdio头文件将生命的函数放在namespace std中
#include<cstdio>
std::fopen();
-------------------------------------------------------------------------------

===============================================================================
无条件终止
    abort 不调用atexit
    exit  和正常退出一样反序调用atexit
有条件终止
    assert //逻辑错误，不可能发生的情况
-------------------------------------------------------------------------------


===============================================================================
goto setjmp longjmp jmp_buf
setjmp(jum_buf) 这个上下文包括程序存放位置、栈和框架指针,其它重要的寄存器和内存
数据。当初始化完 jump 的上下文,setjmp()返回 0 值。
longjmp(j, r), r就事异常对象，不过是一个整数而已

setjmp不能在longjmp之前返回,否则所填充的jmp_buf就无效了

用setjmp和longjmp来模拟异常

if(setjmp(j)==0)
{
    /* A */
    raise_exception();
    /* B */
}
else
{
    /* C */
}

A处时正常代码，C处时异常处理，B处不可能到达
-------------------------------------------------------------------------------


===============================================================================
C函数库也提供了标准的(虽然原始的)“事件”处理包。这个包定义了一组事件和信
号,以及标准的方法来触发和处理它们

信号安全 可重入 异常安全 中断安全
-------------------------------------------------------------------------------


===============================================================================
c++中的异常
void f() throw(int, some_class_type) //抛出 int some_class_type 异常
void f() throw()                     //不抛出异常
void f()                             //可能抛出任何异常
vodi f() throw(...)                  //可能抛出任何异常

namespace std
{
std::exception:
    std::logic_error:
        std::domain_error;
        std::invalid_error;
        std::out_of_range;
        std::length_erorr;
    std::runtime_error:
        std::range_error;
        std::overflow_error;
        std::underflow_error;
}
std::bad_exception;
void terminate()
void unexcepted()
typedef void (*terminate_handler) ();
typedef void (*unexpected_handler) ();
terminate_handler set_terminate(terminate_handler) throw();
unexpected_handler set_unexpected(unexpected_handler) throw();
bool uncaught_exception();

和thread的关系

小总结c/c++的异常处理体系
C 标准库的异常体系处理 C++语言时有如下难题:
1.析构函数被忽略。既然 C 标准库异常体系是为 C 语言设计的,它们不知道 C++的析构函
数。尤其,abort()、exit()和 longjmp()在退栈或程序终止时不调用局部对象的析构函数。

2.繁琐的。查询全局对象或函数返回值导致了代码混乱-你必须在所有可能发生异常的地
方进行明确的异常情况检测,即使是异常情况可能实际上从不发生。因为这种方法是如
此繁琐,程序员们可能会故意“忘了”检测异常情况。

3.无弹性的。Longjmp()“抛出”的只能是简单的 int 型。errno 和 signal()/raise()只
使用了很小的一个值域集合,分辨率很低。Abort()和 exit()总是终止程序。Assert()
只工作在 debug 版本中。

4.非固有的。所有的 C 标准库异常体系都需要运行库的支持,它不是语言内核支持的。

标准 C++异常处理避免了这些短处:
析构安全。在抛异常而进行退栈时,局部对象的析构函数被按正确的顺序调用。
不引人注目的。异常的捕获是暗地里的和自动的。程序员无需因错误检测而搞乱设计。
精确的。因为几乎任何对象都可以被抛出和捕获,程序员可以控制异常的内容和含义。
可伸缩的。每个函数可以有多个 try 块。每个 try 块可以有单个或一组处理函数。每个
处理函数可以捕获单个类型,一组类型或所有类型的异常。
可预测的。函数可以指定它们将抛的异常类型,异常处理函数可以指定它们捕获什么类
型的异常。如果程序违反了其申明,标准库将按可预测的、用户定义的方式运行。
固有的。EH 是 C++语言的一部分。你可以定义、throw 和 catch 异常而不需要包含任何
库。标准的。EH 在所有的标准 C++的实现中都可用。


如果一个包含局部对象的函数没有明确处理异常,但可能传递一个别人抛的异常,
那么函数仍然需要一个 EH 记录和相应的维护代码。

要减小 EH 的空间开销,应该将程序中捕获异常的函数数目减到最小,将函数中
异常处理函数的数目减到最小,将异常处理函数所捕获的异常类型减到最小。

假设一个函数抛出了不在申明规格中的异常,则unexpected被调用,如果unexpected修正了
它，即抛出原函数申明规格中的异常，则程序可以像原函数抛出这个异常一样继续下去,
如果unexpected函数没有修正它，即还是抛出了一个和声明规格不同的异常，则运行时系统
认为程序已经无效了，调用terminate结束程序.但是如果声明规格中有bad_exception异常
，则即使unexpected抛出了一个和规格不同的异常，程序也不会调用terminate，而是将这个
异常转换为bad_exception,再次抛出来，此时程序的其他部分可以捕获这个bad_exception
异常，然后试图恢复程序的运行。

函数 bool uncaught_exception()在被抛出的异常对象完成赋值到匹配的异常处理函数
的异常申明完成初始化之间返回 true。包括其中的退栈过程。如果异常被再次抛出,
uncaught_exception() 从再抛点到再抛对象被再次捕获间返回 true。


void my_unexpected_handler()
{
    printf("in unexpected handler\n");
    throw 2; // allowed by original specification
    //abort();
}
unexcepted()在抛出int型异常后继续原来的逻辑

在过去,对象没有自毁的能力,它们必须构造,并且依赖我们来发现它的状态。它们不
处理构造失败的子对象。

我现在相信 C++标准的行为是正确的:构造函数抛异常将析构正在处理的对象及其包容
对象。我不知道 C++标准委员会制订这个行为的精确原因,但我猜想是:
部分构造的对象将导致一些微妙的错误,因为它的使用者对其的构造程度的假设超过了
实际。同样的类的不同对象将会有出乎意料的和不可预测的不同行为。
编译器需要额外的纪录。当一个部分构造的对象消失时,编译器要避免对它及它的部分
构造的子对象调用析构函数。
对象被构造和对象存在的等价关系将被打破,破坏了 C++的精髓。

对对象的使用者的指导
异常是对象的接口的一部分。如果能够,事先准备好接口可能抛的异常集。如果一个接
口没有提供异常规格申明,而且又不能从其它地方得知其异常行为,那么假设它可能在任何
时候抛任意的异常。换句话说,准备好捕获或至少要过滤所有可能的异常。不要让任何异常在没有被预料到
的情况下进入或离开你的代码;即使你只是简单地传递或重新抛出异常,也必须是经过认真
选择的。

如果你的构造函数抛异常,或你(直接地或间接地)包容的某个子对象抛异常,包容你
的对象的用户对象也将抛异常并因此构造失败。这就是重用你的代码的用户的代价。要确保
这个代价值得。
你没有被强迫要在构造函数里抛异常,老的方法仍然有效的。当你的构造函数遇到错误
时,你必须判断这些错误是致命的还是稍有影响。抛出一个构造异常传递了一个强烈的信息:
这个对象被破坏且无法修补。返回一个构造状态码表明一个不同信息:这个对象被破坏但还
具有功能。

使用异常的一个理由：异常不能被忽略。如果一个函数通过设置一个变量或者返回错误代码
来表征一个异常状态，就没有办法保证调用者一定会检测变量或测试错误代码

防止构造函数里的资源泄露, 构造函数可以抛出异常，但要保证抛出异常时已经构造好的
成员变量被析构掉，这一点可以使用auto_ptr之类的只能指针做到，无论这个成员的构造
发生在初始化列表里，还是构造函数体里

如果把那些声明为指针的类成员替换为他们相应的auto_ptr对象，在发生异常的时候就可以
避免资源泄露，而且免去了在析构函数中手工释放资源的必要，此外，还可以像处理非常量
指针那样以得体的方式来处理常量成员指针

阻止异常传递到析构函数以外，理由：
1.在异常进行到堆栈解开部分的时候，它可以阻止terminate函数被调用
2.它确保析构函数能做完他们该做的事情，如果析构函数中间抛出异常，那么后面的代码就
  执行不到了

抛出异常时，异常对象总是要被拷贝，如果以传值的方式被捕获，它们被拷贝了两次
作为异常被抛出的对象，没有那么多类型转换，只会从派生类转换到其类，同时被捕获时
是按照catch块的顺序来的
如果要把捕获到的对象rethrow，最好调用throw; 而不是throw excepion；因为后者会再
调用一次拷贝

同时记住拷贝永远是其于对象的静态类型
void passAndThrowWidget()
{
    SpecialWidget localSpecialWidget;
    Widget& rw=localSpecialWidget;
    throw rw;
}
则当捕获时，捕获的异常对象一定是Widget而表示SpecialWidget类型

通过引用来捕获异常, 一次拷贝，不会切割等等好处，类型正确(动态类型)

为了避免开销，你应该避免没有不要的情况下使用try块，即便没有异常抛出也需要
5%-10%的大小和效率开销

-------------------------------------------------------------------------------


===============================================================================
new 和 delete
B* p = new D;
B* p = operator new(sizeof(D))
D::D(p) //p is this ptr

delete p;
D::~D(p);
operator delete(p);

p = new D[N];
p = operateor new(size(D) * N + _v);
for(size_t _i(0); _i<N; ++_i;)
{
    D::D(&p[_i]);
}

delete[] p;
for(size_t _i(N); _i>0; --_i)
{
    D::~D(&p[i]);
}
operator delete[] p;

一般程序中的new和delete是两个表达式，编译器会把它们翻译为函数调用

如果 T 的构造函数(比如在部分构造完成时)抛了异常,operator delete 被隐含调用了来释放分配的内存,
这一步时c++标准承诺的，程序员只要知道有这么回事即可

在*p 前面的字节中保存元素个数。其存储空间来自于 new[]操作时_v 字节的额外开销。
由标准运行库维护一个私有的 N 对 p 的映射表。

Placement syntax has four main uses: default placement, preventing exceptions,
custom allocators, and debugging.

default new 失败会throw std::bad_alloc, 你也可以让它不抛异常而返回null

int main ()
{
    // Call the function operator new(std::size_t, const std::nothrow_t &) and
    // (if successful) construct the object.
    T * p = new (std::nothrow) T ;
    if (p)
    {
        // The storage has been allocated and the constructor called.
        delete p ;
    }
    else
    {
        ; // An error has occurred.  No storage has been allocated and no object constructed.
    }
    return 0
}

function try blocks 用来捕获初始化列表中的异常(构造函数中的异常)
function try blocks 更像是个异常过滤器，而不是异常处理函数，因为捕获了也不能做什么，还是又抛出去了

buffer::buffer(size_t const count)
try
: p(new char[count])
{
}
catch
{
    abort();
}

new 可以和 malloc 一样使用，此时只分配原始内存，并不初始化（构造）任何对象，接下来可以再利用
placement new 在分配的内存上构在相应的对象，但是需要注意，此时的析构和释放内存需要两步

void* rawMemory = operator new[](10*sizeof(A));//分配一个数组
A* array = static_cast<A*>(rawMemory); //函数调用

for(int i=0; i<10; ++i)
{
    new (array+i) A(arg);
}
此技术可以在一个类没有默认构造函数时创建一个数组, 但是删除时就比较麻烦了
for(int i=9; i>=0; --i)
{
    array[i].~A();
}
operator delete[] (rawMemory); //函数调用


内建于语言的new操作符做两件事:
1.分配足够的内存
2.在分配的内存上构造对象
你不能改变它的含义,你能改变的是如何为对象分配内存
new操作府通过调用一个函数来完成必需的内存分配，你可以重写或重载这个函数
这个函数的声明通常如下：
void* operator new(size_t size)
你可以直接调用它来像malloc一样分配内存,虽然一般不这么做

如果你想定制自己内存分配过程，你应该自己写一个operator new函数，然后使用new操作符
new操作符会调用你自己的operator new函数

如果想在已知的内存上建立一个对象，可以使用placement new
placement new会调用
void* operator new(size_t, void* location)
{
    return location;
}
来分配内存



https://en.wikipedia.org/wiki/Placement_syntax
http://www.drdobbs.com/cpp/calling-constructors-with-placement-new/232901023
-------------------------------------------------------------------------------


===============================================================================
实现[]操作符的时候，一般需要返回引用，因为需要支持 v[5]=10, 这样的赋值操作

类型转换
static_cast<type>(expression), 和c风格的类型转换差不多
不能通过static_cast把struct转换成int，也不能把double转换成指针, 和在c中一样

const_cast<>()去除一个表达式的const/volatile属性
const SpecialWidget& csw=sw;
const_cast<SpecialWidget*>(&csw)和(SpecialWidget*)&csw一样，但前者更好读一些

dynamic_cast继承体系中向下转换,可以知道转换是否成功，失败:0对指针，失败:异常对引用

reinterpret_cast,转换结果由编译器而定，不可移植

-------------------------------------------------------------------------------



===============================================================================
静态类型 动态类型
运行时多态 编译时多态

不要把多态应用于数组，多态和指针运算就是不能用在一起，而数组操作几乎总要涉及指针运算

具体类从不继承自其他具体类

绝大部分纯虚函数没有实现，但纯虚析构函数必须要有实现，因为派生类的析构函数要调用它
纯虚和有没有实现之间没有任何关系，纯虚函数说明不能实例化这样的对象，和该函数有没有
实现没有关系
-------------------------------------------------------------------------------


===============================================================================
运算符
除非确实需要，否则不要提供类型转换函数，对于单参构造函数，使用explicit 关键字
通常来说，允许编译器进行隐式类型转换时弊大于利的
编译器进行隐式类型转换的规则非常复杂：其中一条是:
隐式的转换序列不能包含多于一个的用户自定义类型转换

自增运算符和自减元算符
class UPInt
{
public:
    UPInt& operator++();
    const UPInt operator++(int);
    ...
}
int参数用来区分前缀和后缀，const返回值，阻止用户写出 o++++ 这样不复合直观的和
内建类型int的后缀用法不一致的用法

不要重载 && || , 操作符, 因为&& ||是短路求值的，参数的求值顺序是一定的，
但是一旦重载，你就没法控制参数的求值顺序和没有短路求值的语义了，这和&& ||的内建
语义非常不同，太容易导致混乱

-------------------------------------------------------------------------------


===============================================================================
c++设计新思维点滴

设计实现某些原则

良好的设计应该在编译期表示出大部分constrains(约束条件，规范)

policy-based class design
host class public inherits policy class
此时需要注意和普通继承的不同之处，其实反向的，由基类的实现来策略化派生类
注意policy class析构函数, 最好不要设计虚数(效率问题)，如果想阻止用户这样使用
Policy* p = new Host; //这样使用的话，必须为Policy定义虚析构函数，否则不能调用
delete p;             //的是Policy的析构函数
你可以定义一个potected的非虚析构函数，这样既不影响效率，也可以阻止用户写出上面
这样的代码

-------------------------------------------------------------------------------

===============================================================================
c++沉思录点滴

抽象就是有选择地忽略
编程就是通过抽象来忽略此刻我们并不重视的因素
c++使我能在自己智力所及的范围内使用一些高超技术，而对我来说，用c实现这些技术太难了
我被c++吸引，很大程度上因为数据抽象，而不是面向对象编程
-------------------------------------------------------------------------------



